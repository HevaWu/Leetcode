/*
Given a rectangle of size n x m, find the minimum number of integer-sided squares that tile the rectangle.



Example 1:



Input: n = 2, m = 3
Output: 3
Explanation: 3 squares are necessary to cover the rectangle.
2 (squares of 1x1)
1 (square of 2x2)
Example 2:



Input: n = 5, m = 8
Output: 5
Example 3:



Input: n = 11, m = 13
Output: 6


Constraints:

1 <= n <= 13
1 <= m <= 13

*/

/*
Solution 1:
DP + greedy

Pruning 1: Try largest possible squares first to prune DFS.
Pruning 2: Use results generated by (naive) DP or greedy discussed above as smaller upper bounds of true answers.
After actual testing up to 30 * 30, DP upper bounds work better.
Visualization of heights

For any positive integers m and n, we further denote the result generated by DP as dp(m, n) and the result generated by greedy as gd(m, n). We purpose that s(m, n) <= dp(m, n) <= gd(m, n) always holds. It is pretty intuitive but I don't know how to prove.

Time Complexity: O(nm*min(m,n) + )
*/
class Solution {
    func tilingRectangle(_ n: Int, _ m: Int) -> Int {
        if n == m { return 1 }
        if n > m { return tilingRectangle(m, n) }

        var dp = Array(
            repeating: Array(repeating: 0, count: m+1),
            count: n+1
        )

        for i in 1...n {
            for j in 1...m {
                if i == j {
                    dp[i][j] = 1
                    continue
                }
                dp[i][j] = i * j
                if i/2 >= 1 {
                   for k in 1...(i/2) {
                        dp[i][j] = min(dp[i][j], dp[i-k][j] + dp[k][j])
                    }
                }

                if j/2 >= 1 {
                    for k in 1...(j/2) {
                        dp[i][j] = min(dp[i][j], dp[i][j-k] + dp[i][k])
                    }
                }
            }
        }

        var rec = dp[n][m]
        var height = Array(repeating: 0, count: n)
        dfs(n, m, &height, 0, &rec)
        return rec
    }

    func dfs(_ n: Int, _ m: Int,
             _ height: inout [Int], _ count: Int, _ rec: inout Int) {
        if count >= rec { return }
        var left = 0
        var minHeight = m
        for i in 0..<n {
            if height[i] < minHeight {
                minHeight = height[i]
                left = i
            }
        }

        if minHeight == m {
            rec = min(count, rec)
        }

        var right = left
        while right < n, height[left] == height[right],
        right-left+minHeight < m {
            right += 1
        }

        for i in left..<right {
            height[i] += right - left
        }

        guard right-left >= 1 else { return }
        for size in stride(from: right-left, through: 1, by: -1) {
            dfs(n, m, &height, count+1, &rec)
            // update rectangle to contain next smaller square
            // print(left, left+size-1)
            for i in left..<(left+size-1) {
                height[i] -= 1
            }
            height[left+size-1] -= size
        }
    }
}